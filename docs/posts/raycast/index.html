<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Raycast | VR Interaction Project 2022</title>
<meta name="keywords" content="">
<meta name="description" content="Using Raycast to &ldquo;blow wind&rdquo; at objects
&ldquo;Raycast in Unity is a Physics function that projects a Ray into the scene, returning a boolean value if a target was successfully hit. When this happens, information about the hit, such as the distance, position or a reference to the object’s Transform, can be stored in a Raycast Hit variable for further use.&rdquo; &ndash; John French: Raycasts in Unity, made easy. Published on gamedevbeginner.">
<meta name="author" content="">
<link rel="canonical" href="https://4yjo.github.io/InteractVR/posts/raycast/">
<link crossorigin="anonymous" href="/InteractVR/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/InteractVR/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://4yjo.github.io/InteractVR/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://4yjo.github.io/InteractVR/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://4yjo.github.io/InteractVR/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://4yjo.github.io/InteractVR/apple-touch-icon.png">
<link rel="mask-icon" href="https://4yjo.github.io/InteractVR/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Raycast" />
<meta property="og:description" content="Using Raycast to &ldquo;blow wind&rdquo; at objects
&ldquo;Raycast in Unity is a Physics function that projects a Ray into the scene, returning a boolean value if a target was successfully hit. When this happens, information about the hit, such as the distance, position or a reference to the object’s Transform, can be stored in a Raycast Hit variable for further use.&rdquo; &ndash; John French: Raycasts in Unity, made easy. Published on gamedevbeginner." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://4yjo.github.io/InteractVR/posts/raycast/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-14T16:49:35+01:00" />
<meta property="article:modified_time" content="2023-02-14T16:49:35+01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Raycast"/>
<meta name="twitter:description" content="Using Raycast to &ldquo;blow wind&rdquo; at objects
&ldquo;Raycast in Unity is a Physics function that projects a Ray into the scene, returning a boolean value if a target was successfully hit. When this happens, information about the hit, such as the distance, position or a reference to the object’s Transform, can be stored in a Raycast Hit variable for further use.&rdquo; &ndash; John French: Raycasts in Unity, made easy. Published on gamedevbeginner."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://4yjo.github.io/InteractVR/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Raycast",
      "item": "https://4yjo.github.io/InteractVR/posts/raycast/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Raycast",
  "name": "Raycast",
  "description": "Using Raycast to \u0026ldquo;blow wind\u0026rdquo; at objects\n\u0026ldquo;Raycast in Unity is a Physics function that projects a Ray into the scene, returning a boolean value if a target was successfully hit. When this happens, information about the hit, such as the distance, position or a reference to the object’s Transform, can be stored in a Raycast Hit variable for further use.\u0026rdquo; \u0026ndash; John French: Raycasts in Unity, made easy. Published on gamedevbeginner.",
  "keywords": [
    
  ],
  "articleBody": "Using Raycast to “blow wind” at objects\n“Raycast in Unity is a Physics function that projects a Ray into the scene, returning a boolean value if a target was successfully hit. When this happens, information about the hit, such as the distance, position or a reference to the object’s Transform, can be stored in a Raycast Hit variable for further use.” – John French: Raycasts in Unity, made easy. Published on gamedevbeginner.com in June 2021. Source\nThe decision to use Raycasts allowed for a more controlled handling of events compared to using unity’s rigid body - at least for me it soon became much easier to understand.\nVisualize the Raycast with a Line-Renderer The raycast is implemented in the blowWind.cs script attached to the ventilator. I also attached a Line-Renderer-Component to the ventilator that visualises the ray for the players.\nThe script differentiates between two kinds of “wind modes” that the players can change by tapping the touch button of the left controller. If the mode is changed successfully, the visualisation of the rendered line also changes in its thickness. The idea of the two wind modes is to metaphorically adjust the width of the wind-stream coming from the ventilator: With a broader wind-stream objects are moved. Objects that could be moved like that (some parts of the T-Objects as well as the kite) are placed on the layer “bigWind”. The second wind mode, associated to the layer “smallWind” and used for all edges of the T-Object, can be thought of impulses that make obejcts rotate.\nUsing a Layer Mask to controll which objects can be hit The script checks the layer of the hit object using a Unity LayerMask. It is important that colliders are attached to the parts of the objects that should be hit. The video shows a test of my layer mask. If an object was placed on either the “bigWind” (left cube), “smallWind” (middle cube) or “objTask” (right cube) layer the color of the ray was changed from red to blue.\nUsing the layer mask also solved a problem, I had earlier: My Raycast did not cast all objects along its length, so when the kite was moved through the start banner in the beginning of the game, the raycast got “caught” in the collider of the start banner and the kite could not be moved any further. As the start banner is on the default layer, it is ignored by the raycast with the layer mask.\nThe code below shows how object interaction is implemented: First, the layer is checked - only if objects are on the “smallWind” Layer, we proceed with object interaction. In the next step, the tag is checked to define the axis for the rotation.\nThe tag of the object that the ray hits is asked of its parent transform (the collider). The variable indexInput is defined earlier in the script and gets the float value of the left controllers index trigger.\nif (RayMode \u0026\u0026 Physics.Raycast(ray, out hit, rayLength, LayerMask.GetMask(\"smallWind\"))) { if (hit.transform.tag == \"impLeft\") { hit.transform.parent.transform.Rotate(new Vector3(0f,-1f,0f)*indexInput); } else if (hit.transform.tag == \"impRight\") { hit.transform.parent.transform.Rotate(new Vector3(0f,1f,0f)*indexInput); } else if (hit.transform.tag == \"impForward\") { hit.transform.parent.transform.Rotate(new Vector3(1f,0f,0f)*indexInput); } else if (hit.transform.tag == \"impBackward\") { hit.transform.parent.transform.Rotate(new Vector3(-1f,0f,0f)*indexInput); } } Using tags for game objects to define assigned interactions In the second step the objects I wanted to allow the player to interact with (including the kite) were assigned tags that helped to specify actions. For example, if the hit object had the Tag “impRight”, the object should rotate as if it was hit by an wind impulse on the right.\nA special case was the player forward movement, that occured when the middle part was hit. Its collider is tagged “accKite” but instead of just giving one instruction the script uses a mapping (as described in the post on locomotion) to differentiate between four directions (forward, -forward, right, -right). This allowed to safely navigate through the parcour.\n",
  "wordCount" : "655",
  "inLanguage": "en",
  "datePublished": "2023-02-14T16:49:35+01:00",
  "dateModified": "2023-02-14T16:49:35+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://4yjo.github.io/InteractVR/posts/raycast/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "VR Interaction Project 2022",
    "logo": {
      "@type": "ImageObject",
      "url": "https://4yjo.github.io/InteractVR/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://4yjo.github.io/InteractVR" accesskey="h" title="VR Interaction Project 2022 (Alt + H)">VR Interaction Project 2022</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Raycast
    </h1>
    <div class="post-meta"><span title='2023-02-14 16:49:35 +0100 CET'>February 14, 2023</span>

</div>
  </header> 
  <div class="post-content"><p><strong>Using Raycast to &ldquo;blow wind&rdquo; at objects</strong></p>
<p><em>&ldquo;Raycast in Unity is a Physics function that projects a Ray into the scene, returning a boolean value if a target was successfully hit. When this happens, information about the hit, such as the distance, position or a reference to the object’s Transform, can be stored in a Raycast Hit variable for further use.&rdquo;</em>
&ndash; John French: Raycasts in Unity, made easy. Published on gamedevbeginner.com in June 2021. <a href="https://gamedevbeginner.com/raycasts-in-unity-made-easy/">Source</a></p>
<p>The decision to use Raycasts allowed for a more controlled handling of events compared to using unity&rsquo;s rigid body - at least for me it soon became much easier to understand.</p>
<p><em>Visualize the Raycast with a Line-Renderer</em>
The raycast is implemented in the <code>blowWind.cs</code> script attached to the ventilator. I also attached a Line-Renderer-Component to the ventilator that visualises the ray for the players.</p>
<!-- raw HTML omitted -->
<p>The script differentiates between two kinds of &ldquo;wind modes&rdquo; that the players can change by tapping the touch button of the left controller. If the mode is changed successfully, the visualisation of the rendered line also changes in its thickness. The idea of the two wind modes is to metaphorically adjust the width of the wind-stream coming from the ventilator: With a broader wind-stream objects are moved. Objects that could be moved like that (some parts of the T-Objects as well as the kite) are placed on the layer &ldquo;bigWind&rdquo;. The second wind mode, associated to the layer &ldquo;smallWind&rdquo; and used for all edges of the T-Object, can be thought of impulses that make obejcts rotate.</p>
<p><em>Using a Layer Mask to controll which objects can be hit</em>
The script checks the layer of the hit object using a Unity LayerMask. It is important that colliders are attached to the parts of the objects that should be hit. The video shows a test of my layer mask. If an object was placed on either the &ldquo;bigWind&rdquo; (left cube), &ldquo;smallWind&rdquo; (middle cube) or &ldquo;objTask&rdquo; (right cube) layer the color of the ray was changed from red to blue.</p>
<!-- raw HTML omitted -->
<p>Using the layer mask also solved a problem, I had earlier: My Raycast did not cast all objects along its length, so when the kite was moved through the start banner in the beginning of the game, the raycast got &ldquo;caught&rdquo; in the collider of the start banner and the kite could not be moved any further. As the start banner is on the default layer, it is ignored by the raycast with the layer mask.</p>
<p>The code below shows how object interaction is implemented: First, the layer is checked - only if objects are on the &ldquo;smallWind&rdquo; Layer, we proceed with object interaction. In the next step, the tag is checked to define the axis for the rotation.</p>
<p>The tag of the object that the ray hits is asked of its parent transform (the collider). The variable indexInput is defined earlier in the script and gets the float value of the left controllers index trigger.</p>
<pre tabindex="0"><code>if (RayMode &amp;&amp; Physics.Raycast(ray, out hit, rayLength, LayerMask.GetMask(&#34;smallWind&#34;)))
           {

               if (hit.transform.tag == &#34;impLeft&#34;)
               {
                   hit.transform.parent.transform.Rotate(new Vector3(0f,-1f,0f)*indexInput);
               }

               else if (hit.transform.tag == &#34;impRight&#34;)
               {
                   hit.transform.parent.transform.Rotate(new Vector3(0f,1f,0f)*indexInput);
               }

               else if (hit.transform.tag == &#34;impForward&#34;)
               {
                   hit.transform.parent.transform.Rotate(new Vector3(1f,0f,0f)*indexInput);
               }

               else if (hit.transform.tag == &#34;impBackward&#34;)
               {
                   hit.transform.parent.transform.Rotate(new Vector3(-1f,0f,0f)*indexInput);
               }
           }
</code></pre><p><em>Using tags for game objects to define assigned interactions</em>
In the second step the objects I wanted to allow the player to interact with (including the kite) were assigned tags that helped to specify actions. For example, if the hit object had the Tag &ldquo;impRight&rdquo;, the object should rotate as if it was hit by an wind impulse on the right.</p>
<!-- raw HTML omitted -->
<p><img loading="lazy" src="/content/posts/Raycast2.png" alt="Screenshot of modified prefab: The T-Object is divided into several smaller parts that hold colliders and tags. The whole object is on the small-wind layer."  />
</p>
<p>A special case was the player forward movement, that occured when the middle part was hit. Its collider is tagged &ldquo;accKite&rdquo; but instead of just giving one instruction the script uses a mapping (as described in the post on locomotion) to differentiate between four directions (forward, -forward, right, -right). This allowed to safely navigate through the parcour.</p>
<!-- raw HTML omitted -->


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://4yjo.github.io/InteractVR">VR Interaction Project 2022</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
